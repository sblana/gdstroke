#version 460
#extension GL_ARB_shading_language_include : require

layout(local_size_x = 64) in;

#include "common/buffers.glsli"
#include "common/math.glsli"


void main() {
	const uint pixel_edge_idx = gl_GlobalInvocationID.x;

	if (pixel_edge_idx < B_common_desc.num_pixel_edges) {

		// init
		B_compacted_pixel_edge_segmentation.data[pixel_edge_idx].is_inside_initial = store_bool(false);

		if (is_compacted_pixel_edge_idx_valid(int(pixel_edge_idx))) {
			const int contour_pixel_idx = B_compacted_pixel_edge_attribs.data[pixel_edge_idx].to_contour_pixel_idx;
			const PixelEdgeLoopAttribs loop_attribs = B_pixel_edge_loop_attribs.data[B_compacted_pixel_edge_attribs.data[pixel_edge_idx].to_pixel_edge_loop_idx];

			const int num_neighbours = min(INSIDE_OUTSIDE_TEST_MAX_NUM_NEIGHBOURS, loop_attribs.loop_len / 2);

			// load contour pixel orientations
			vec2 contour_pixel_orientations_stack[INSIDE_OUTSIDE_TEST_MAX_WINDOW_SIZE];
			contour_pixel_orientations_stack[num_neighbours] = B_contour_pixel_attribs.data[contour_pixel_idx].orientation;

			for (int forward = 0; forward < 2; ++forward) {
				const int direction = (forward * 2 - 1);
				uint prev_idx = pixel_edge_idx;
				for (int i = 1; i <= num_neighbours; ++i) {
					uint cur_idx = ((forward > 0)
						? (B_compacted_pixel_edge_attribs.data[prev_idx].next_idx)
						: (B_compacted_pixel_edge_attribs.data[prev_idx].prev_idx)
					);
					const int k = i * direction;
					const int cur_contour_pixel_idx = B_compacted_pixel_edge_attribs.data[cur_idx].to_contour_pixel_idx;
					contour_pixel_orientations_stack[num_neighbours + k] = B_contour_pixel_attribs.data[cur_contour_pixel_idx].orientation;
					prev_idx = cur_idx;
				}
			}

			const vec2 pixel_edge_orientation = B_compacted_pixel_edge_attribs.data[pixel_edge_idx].filtered_orientation;
			const float orientation_threshold = U_config.orientation_threshold;
			int times_passed = 0;
			for (int k = -num_neighbours; k <= num_neighbours; ++k) {
				const float orientation_product = dot(pixel_edge_orientation, contour_pixel_orientations_stack[num_neighbours + k]);
				if (orientation_product > orientation_threshold) {
					times_passed += 1;
				}
			}

			const bool is_inside = times_passed > (num_neighbours * 2 + 1) / 2;
			B_compacted_pixel_edge_segmentation.data[pixel_edge_idx].is_inside_initial = store_bool(is_inside);
		}
	}
}
