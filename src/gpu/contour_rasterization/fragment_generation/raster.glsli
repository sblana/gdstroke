#extension GL_ARB_shading_language_include : enable
#include "common/buffers.glsli"

vec3 model_norm_to_view_norm(mat4 model_to_world, vec3 model_norm) {
	return vec3(U_scene_data.cur.view_matrix * model_to_world * vec4(model_norm, 0.0));
}

vec3 model_pos_to_view_pos(mat4 model_to_world, vec3 model_pos) {
	return vec3(U_scene_data.cur.view_matrix * model_to_world * vec4(model_pos, 1.0));
}

vec4 view_pos_to_ndc_pos(vec3 view_pos) {
	vec4 clip_pos = U_scene_data.cur.projection_matrix * vec4(view_pos, 1.0);
	clip_pos.z += U_config.depth_bias;
	return vec4(clip_pos.xyz / clip_pos.w, clip_pos.w);
}

vec2 ndc_pos_to_screen_pos(vec4 ndc_pos) {
	return (ndc_pos.xy * 0.5 + 0.5) * U_scene_data.cur.viewport_size;
}

vec4[2] pre_raster_edge(int global_edge_idx) {
	const int mesh_instance_idx = B_global_edges.data[global_edge_idx].to_mesh_instance_idx;
	const MeshInstanceMapsData mesh_instance_maps = B_mesh_instance_maps.data[mesh_instance_idx];

	MeshDescData mesh_desc = B_mesh_desc.data[B_mesh_instance_desc.data[mesh_instance_idx].to_mesh_idx];

	const int local_edge_idx = int(global_edge_idx) - mesh_instance_maps.first_global_edge_idx;
	const LocalEdgeData local_edge_data = mesh_desc.local_edge_buffer.data[local_edge_idx];


	bool reverse_vertex_order = B_global_faces.data[local_edge_data.to_local_face_idxs[0] + mesh_instance_maps.first_global_face_idx].is_backfacing;
	vec3 first_vert_view_pos = model_pos_to_view_pos(
		B_mesh_instance_desc.data[mesh_instance_idx].model_to_world,
		mesh_desc.local_vertex_buffer.data[ local_edge_data.to_local_vertex_idxs[0] ].position
	);
	vec3 secnd_vert_view_pos = model_pos_to_view_pos(
		B_mesh_instance_desc.data[mesh_instance_idx].model_to_world,
		mesh_desc.local_vertex_buffer.data[ local_edge_data.to_local_vertex_idxs[1] ].position
	);

	vec4 first_vert_ndc_pos = view_pos_to_ndc_pos(first_vert_view_pos);
	vec4 secnd_vert_ndc_pos = view_pos_to_ndc_pos(secnd_vert_view_pos);
	// HACK: needed for proper clipping, but just a guess
	first_vert_ndc_pos *= vec4(sign(first_vert_ndc_pos.ww), vec2(1.0));
	secnd_vert_ndc_pos *= vec4(sign(secnd_vert_ndc_pos.ww), vec2(1.0));

	vec4 result[2];
	result[uint( reverse_vertex_order)] = first_vert_ndc_pos;
	result[uint(!reverse_vertex_order)] = secnd_vert_ndc_pos;

	return result;
}

vec4 perspective_interpolate_edge(vec4 verts_ndc[2], float weight) {
	float w_reciprocal = mix(1.0 / verts_ndc[0].w, 1.0 / verts_ndc[1].w, weight);
	vec3 ndc = mix(verts_ndc[0].xyz, verts_ndc[1].xyz, weight);
	return vec4(ndc, w_reciprocal);
}

bool line_determine_axis_dominance(ivec2 start_point, ivec2 end_point) {
	const ivec2 diff = abs(end_point - start_point);
	const bool is_y_dominant = diff.x < diff.y;
	return is_y_dominant;
}

int calc_local_y_along_bresline(ivec2 diff, int i_along_x) {
	return (2 * diff[1] * i_along_x + diff[0]) / (2 * diff[0]);
}

int calc_local_x_along_bresline(ivec2 diff, int i_along_y) {
	return (2 * diff[0] * i_along_y + diff[1]) / (2 * diff[1]);
}
