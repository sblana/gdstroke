#include "common/buffers.glsli"

vec3 model_norm_to_view_norm(vec3 model_norm) {
	return vec3(U_scene_data.cur.view_matrix * B_mesh_desc.model_to_world * vec4(model_norm, 0.0));
}

vec3 model_pos_to_view_pos(vec3 model_pos) {
	return vec3(U_scene_data.cur.view_matrix * B_mesh_desc.model_to_world * vec4(model_pos, 1.0));
}

vec4 view_pos_to_ndc_pos(vec3 view_pos) {
	vec4 clip_pos = U_scene_data.cur.projection_matrix * vec4(view_pos, 1.0);
	return vec4(clip_pos.xyz / clip_pos.w, clip_pos.w);
}

vec2 ndc_pos_to_screen_pos(vec4 ndc_pos) {
	return (ndc_pos.xy * 0.5 + 0.5) * U_scene_data.cur.viewport_size;
}

vec4[2] pre_raster_edge(int edge_idx) {
	bool reverse_vertex_order = B_face_backfacing.backfacing[B_edge_to_face.face_idxs[edge_idx][0]];
	vec3 first_vert_view_pos = model_pos_to_view_pos(B_vertex.position[B_edge_to_vertex.vertex_idxs[edge_idx][0]].xyz);
	vec3 secnd_vert_view_pos = model_pos_to_view_pos(B_vertex.position[B_edge_to_vertex.vertex_idxs[edge_idx][1]].xyz);

	vec4 first_vert_ndc_pos = view_pos_to_ndc_pos(first_vert_view_pos);
	vec4 secnd_vert_ndc_pos = view_pos_to_ndc_pos(secnd_vert_view_pos);

	// TODO: clipping/discarding

	vec4 result[2];
	result[uint( reverse_vertex_order)] = first_vert_ndc_pos;
	result[uint(!reverse_vertex_order)] = secnd_vert_ndc_pos;

	return result;
}

vec4 perspective_interpolate_edge(vec4 verts_ndc[2], float weight) {
	float w_reciprocal = mix(1.0 / verts_ndc[0].w, 1.0 / verts_ndc[1].w, weight);
	vec3 ndc = mix(verts_ndc[0].xyz, verts_ndc[1].xyz, weight);
	return vec4(ndc, w_reciprocal);
}

bool line_determine_axis_dominance(ivec2 start_point, ivec2 end_point) {
	const ivec2 diff = abs(end_point - start_point);
	const bool is_y_dominant = diff.x < diff.y;
	return is_y_dominant;
}

int calc_local_y_along_bresline(ivec2 diff, int i_along_x) {
	return (2 * diff[1] * i_along_x + diff[0]) / (2 * diff[0]);
}

int calc_local_x_along_bresline(ivec2 diff, int i_along_y) {
	return (2 * diff[0] * i_along_y + diff[1]) / (2 * diff[1]);
}
