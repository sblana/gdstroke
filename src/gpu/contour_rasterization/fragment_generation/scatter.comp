#version 450
#extension GL_ARB_shading_language_include : enable

layout(local_size_x = 64) in;

#include <common/math.glsli>
#include "buffers.glsli"
#include "raster.glsli"


void main() {
	const int contour_edge_idx = int(gl_WorkGroupID.x);
	const int edge_idx = B_contour_edge_to_edge.idx[contour_edge_idx];
	const vec4 verts_clipped_ndc[2] = pre_raster_edge(edge_idx);
	const vec2 verts_clipped_screen[2] = {ndc_pos_to_screen_pos(verts_clipped_ndc[0]), ndc_pos_to_screen_pos(verts_clipped_ndc[1])};

	const bool is_first_face_frontfacing = !B_face_backfacing.backfacing[B_edge_to_face.face_idxs[edge_idx][0]];
	const int front_face_idx = B_edge_to_face.face_idxs[edge_idx][int(is_first_face_frontfacing)];
	const vec3 front_face_view_normal = mat3x3(U_scene_data.cur.view_matrix) * mat3x3(B_mesh_desc.model_to_world) * B_face_normal.normal[front_face_idx];

	const vec2 contour_orientation = normalize(verts_clipped_screen[1] - verts_clipped_screen[0]);

	const bool is_y_dominant = line_determine_axis_dominance(ivec2(verts_clipped_screen[0]), ivec2(verts_clipped_screen[1]));
	const bool is_first_point_smallest = (
		int(verts_clipped_screen[0][int(is_y_dominant)]) <
		int(verts_clipped_screen[1][int(!is_y_dominant)])
	);
	const ivec2 smallest_point = ivec2(verts_clipped_screen[int(!is_first_point_smallest)]);
	const ivec2 diff = ivec2(verts_clipped_screen[int(is_first_point_smallest)]) - ivec2(verts_clipped_screen[int(!is_first_point_smallest)]);

	const uint first_fragment_global_idx = B_contour_edge_to_contour_fragment.data[contour_edge_idx].first_fragment_idx;
	const uint num_fragments = B_contour_edge_to_contour_fragment.data[contour_edge_idx].num_fragments;
	uint num_blocks = gl_WorkGroupSize.x;
	const uint fragments_per_block = udiv_ceil(num_fragments, num_blocks);
	num_blocks = udiv_ceil(num_fragments, fragments_per_block);

	if (gl_LocalInvocationID.x < num_blocks) {

		const uint block_idx = gl_LocalInvocationID.x;
		const int start_frag_idx = int(fragments_per_block * block_idx);
		const int final_frag_idx = int(min(start_frag_idx + fragments_per_block, num_fragments)) - 1;
		// for-loop might be kind of silly since we are solving for the line at every step.
		// perhaps processors could be mapped to fragments directly instead of to contour edges
		for (int frag_idx = start_frag_idx; frag_idx <= final_frag_idx; ++frag_idx) {
			ivec2 pixel_coord = ivec2(0,0);
			if (!is_y_dominant) {
				pixel_coord.x = smallest_point.x + frag_idx;
				pixel_coord.y = smallest_point.y + calc_local_y_along_bresline(diff, frag_idx);
			}
			else {
				pixel_coord.y = smallest_point.y + frag_idx;
				pixel_coord.x = smallest_point.x + calc_local_x_along_bresline(diff, frag_idx);
			}
			const float interpolation_weight = (frag_idx + 0.5) / float(num_fragments);
			const vec4 interpolated_ndc = perspective_interpolate_edge(verts_clipped_ndc, interpolation_weight);
			const float godot_depth = -interpolated_ndc.z / 2.0 + 0.5 + U_config.depth_bias;
			B_contour_fragment_normal_depth.normal_depth[first_fragment_global_idx + frag_idx].w = godot_depth;
			B_contour_fragment_normal_depth.normal_depth[first_fragment_global_idx + frag_idx].xyz = front_face_view_normal;
			B_contour_fragment_orientation.orientation[first_fragment_global_idx + frag_idx] = contour_orientation;
			B_contour_fragment_pixel_coord.pixel_coord[first_fragment_global_idx + frag_idx] = pixel_coord;
		}
	}
}
