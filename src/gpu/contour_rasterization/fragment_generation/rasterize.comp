#version 450
#extension GL_ARB_shading_language_include : enable

layout(local_size_x = 64) in;

#include "common/buffers.glsli"
#include "common/math.glsli"
#include "raster.glsli"


void main() {
	const uint fragment_idx = gl_GlobalInvocationID.x;
	if (fragment_idx >= B_contour_desc.num_contour_fragments) {
		return;
	}

	const int contour_edge_idx = B_contour_fragment_to_contour_edge.idx[fragment_idx];
	if (B_contour_edge_is_discarded.discarded[contour_edge_idx]) {
		return;
	}
	const int edge_idx = B_contour_edge_to_edge.idx[contour_edge_idx];
	const vec4 verts_ndc[2] = pre_raster_edge(edge_idx);
	const float clip_t[2] = B_contour_edge_clip_t.t[contour_edge_idx];
	const vec4 verts_clipped_ndc[2] = {
		verts_ndc[0] + (verts_ndc[1] - verts_ndc[0]) * clip_t[0],
		verts_ndc[0] + (verts_ndc[1] - verts_ndc[0]) * clip_t[1]
	};
	const vec2 verts_clipped_screen[2] = {ndc_pos_to_screen_pos(verts_clipped_ndc[0]), ndc_pos_to_screen_pos(verts_clipped_ndc[1])};

	const bool is_first_face_frontfacing = !B_face_backfacing.backfacing[B_edge_to_face.face_idxs[edge_idx][0]];
	const int front_face_idx = B_edge_to_face.face_idxs[edge_idx][int(is_first_face_frontfacing)];
	const vec3 front_face_view_normal = model_norm_to_view_norm(B_face_normal.normal[front_face_idx].xyz);

	const vec2 contour_orientation = normalize(verts_clipped_screen[1] - verts_clipped_screen[0]);

	#ifdef RASTER_METHOD_BRESENHAM
	const bool is_y_dominant = line_determine_axis_dominance(ivec2(verts_clipped_screen[0]), ivec2(verts_clipped_screen[1]));
	const bool is_first_point_smallest = (
		int(verts_clipped_screen[0][int(is_y_dominant)]) <
		int(verts_clipped_screen[1][int(is_y_dominant)])
	);
	const ivec2 smallest_point = ivec2(verts_clipped_screen[int(!is_first_point_smallest)]);
	const ivec2 diff = ivec2(verts_clipped_screen[int(is_first_point_smallest)]) - ivec2(verts_clipped_screen[int(!is_first_point_smallest)]);
	const bool is_non_dominant_axis_negative = diff[int(!is_y_dominant)] < 0;
	const ivec2 abs_diff = abs(diff);
#endif

#ifdef RASTER_METHOD_DDA
	const bool f_is_y_dominant = abs(contour_orientation.x) < abs(contour_orientation.y);
	const vec2 f_diff = verts_clipped_screen[1] - verts_clipped_screen[0];
	const float f_sign = sign(f_diff[int(f_is_y_dominant)]);
	const float f_slope = f_diff[int(!f_is_y_dominant)] / f_diff[int(f_is_y_dominant)];
	const float f_non_dominant_intercept = verts_clipped_screen[0][int(!f_is_y_dominant)] - verts_clipped_screen[0][int(f_is_y_dominant)] * f_slope;
#endif

	const uint first_fragment_global_idx = B_contour_edge_to_contour_fragment.data[contour_edge_idx].first_fragment_idx;
	const uint num_fragments = B_contour_edge_to_contour_fragment.data[contour_edge_idx].num_fragments;
	const int fragment_local_idx = int(fragment_idx) - int(first_fragment_global_idx);
	{
		ivec2 pixel_coord = ivec2(0,0);

		#ifdef RASTER_METHOD_BRESENHAM
		if (!is_y_dominant) {
			pixel_coord.x = smallest_point.x + fragment_local_idx;
			if (!is_non_dominant_axis_negative) {
				pixel_coord.y = smallest_point.y + calc_local_y_along_bresline(abs_diff, fragment_local_idx);
			}
			else {
				pixel_coord.y = smallest_point.y -calc_local_y_along_bresline(abs_diff, fragment_local_idx);
			}
		}
		else {
			pixel_coord.y = smallest_point.y + fragment_local_idx;
			if (!is_non_dominant_axis_negative) {
				pixel_coord.x = smallest_point.x + calc_local_x_along_bresline(abs_diff, fragment_local_idx);
			}
			else {
				pixel_coord.x = smallest_point.x - calc_local_x_along_bresline(abs_diff, fragment_local_idx);
			}
		}
		const float interpolation_weight = (fragment_local_idx + 0.5) / float(num_fragments) * (int(is_first_point_smallest) * 2 - 1) + int(!is_first_point_smallest);
		#endif

		#ifdef RASTER_METHOD_DDA
		pixel_coord[int( f_is_y_dominant)] = int(verts_clipped_screen[0][int( f_is_y_dominant)] + fragment_local_idx * f_sign);
		pixel_coord[int(!f_is_y_dominant)] = int((verts_clipped_screen[0][int(f_is_y_dominant)] + fragment_local_idx * f_sign) * f_slope + f_non_dominant_intercept);
		const float interpolation_weight = (fragment_local_idx + 0.5) / float(num_fragments);
		#endif

		const vec4 interpolated_ndc = perspective_interpolate_edge(verts_clipped_ndc, interpolation_weight);
		const float godot_depth = interpolated_ndc.z;
		B_contour_fragment_attribs.data[fragment_idx].pixel_coord = pixel_coord;
		B_contour_fragment_attribs.data[fragment_idx].orientation = contour_orientation;
		B_contour_fragment_attribs.data[fragment_idx].normal_depth.xyz = front_face_view_normal;
		B_contour_fragment_attribs.data[fragment_idx].normal_depth.w = godot_depth;
	}
}
