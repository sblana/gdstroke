#version 450
#extension GL_ARB_shading_language_include : enable

layout(local_size_x = 64) in;

#include "common/buffers.glsli"
#include "common/math.glsli"
#include "raster.glsli"


void main() {
	const uint fragment_idx = gl_GlobalInvocationID.x;
	if (fragment_idx >= B_contour_desc.num_contour_fragments) {
		return;
	}

	const int contour_edge_idx = B_contour_fragment_attribs.data[fragment_idx].to_contour_edge_idx;
	if (bool(B_contour_edge_attribs.data[contour_edge_idx].is_discarded)) {
		return;
	}
	const int global_edge_idx = B_contour_edge_attribs.data[contour_edge_idx].to_global_edge_idx;
	const vec4 verts_ndc[2] = pre_raster_edge(global_edge_idx);
	const float clip_t[2] = B_contour_edge_attribs.data[contour_edge_idx].clip_t;
	const vec4 verts_clipped_ndc[2] = {
		verts_ndc[0] + (verts_ndc[1] - verts_ndc[0]) * clip_t[0],
		verts_ndc[0] + (verts_ndc[1] - verts_ndc[0]) * clip_t[1]
	};
	const vec2 verts_clipped_screen[2] = {ndc_pos_to_screen_pos(verts_clipped_ndc[0]), ndc_pos_to_screen_pos(verts_clipped_ndc[1])};

	const int mesh_instance_idx = B_global_edges.data[global_edge_idx].to_mesh_instance_idx;
	const MeshInstanceMapsData mesh_instance_maps = B_mesh_instance_maps.data[mesh_instance_idx];
	MeshDescData mesh_desc = B_mesh_desc.data[B_mesh_instance_desc.data[mesh_instance_idx].to_mesh_idx];
	const int local_edge_idx = int(global_edge_idx) - mesh_instance_maps.first_global_edge_idx;
	const LocalEdgeData local_edge_data = mesh_desc.local_edge_buffer.data[local_edge_idx];

	const bool is_first_face_frontfacing = !B_global_faces.data[local_edge_data.to_local_face_idxs[0] + mesh_instance_maps.first_global_face_idx].is_backfacing;
	const int front_face_idx = local_edge_data.to_local_face_idxs[int(is_first_face_frontfacing)];
	const vec3 front_face_view_normal = model_norm_to_view_norm(
		B_mesh_instance_desc.data[mesh_instance_idx].model_to_world,
		mesh_desc.local_face_buffer.data[front_face_idx].normal
	);

	const vec2 contour_orientation = normalize(verts_clipped_screen[1] - verts_clipped_screen[0]);

	#ifdef RASTER_METHOD_BRESENHAM
	const bool is_y_dominant = line_determine_axis_dominance(ivec2(verts_clipped_screen[0]), ivec2(verts_clipped_screen[1]));
	const bool is_first_point_smallest = (
		int(verts_clipped_screen[0][int(is_y_dominant)]) <
		int(verts_clipped_screen[1][int(is_y_dominant)])
	);
	const ivec2 smallest_point = ivec2(verts_clipped_screen[int(!is_first_point_smallest)]);
	const ivec2 diff = ivec2(verts_clipped_screen[int(is_first_point_smallest)]) - ivec2(verts_clipped_screen[int(!is_first_point_smallest)]);
	const bool is_non_dominant_axis_negative = diff[int(!is_y_dominant)] < 0;
	const ivec2 abs_diff = abs(diff);
#endif

#ifdef RASTER_METHOD_DDA
	const bool f_is_y_dominant = abs(contour_orientation.x) < abs(contour_orientation.y);
	const vec2 f_diff = verts_clipped_screen[1] - verts_clipped_screen[0];
	const float f_sign = sign(f_diff[int(f_is_y_dominant)]);
	const float f_slope = f_diff[int(!f_is_y_dominant)] / f_diff[int(f_is_y_dominant)];
	const float f_non_dominant_intercept = verts_clipped_screen[0][int(!f_is_y_dominant)] - verts_clipped_screen[0][int(f_is_y_dominant)] * f_slope;
#endif

	const Range fragment_range = B_contour_edge_attribs.data[contour_edge_idx].contour_fragment_range;
	const int fragment_local_idx = int(fragment_idx) - fragment_range.first;
	{
		ivec2 pixel_coord = ivec2(0,0);

		#ifdef RASTER_METHOD_BRESENHAM
		if (!is_y_dominant) {
			pixel_coord.x = smallest_point.x + fragment_local_idx;
			if (!is_non_dominant_axis_negative) {
				pixel_coord.y = smallest_point.y + calc_local_y_along_bresline(abs_diff, fragment_local_idx);
			}
			else {
				pixel_coord.y = smallest_point.y -calc_local_y_along_bresline(abs_diff, fragment_local_idx);
			}
		}
		else {
			pixel_coord.y = smallest_point.y + fragment_local_idx;
			if (!is_non_dominant_axis_negative) {
				pixel_coord.x = smallest_point.x + calc_local_x_along_bresline(abs_diff, fragment_local_idx);
			}
			else {
				pixel_coord.x = smallest_point.x - calc_local_x_along_bresline(abs_diff, fragment_local_idx);
			}
		}
		const float interpolation_weight = (fragment_local_idx + 0.5) / float(fragment_range.count) * (int(is_first_point_smallest) * 2 - 1) + int(!is_first_point_smallest);
		#endif

		#ifdef RASTER_METHOD_DDA
		pixel_coord[int( f_is_y_dominant)] = int(verts_clipped_screen[0][int( f_is_y_dominant)] + fragment_local_idx * f_sign);
		pixel_coord[int(!f_is_y_dominant)] = int((verts_clipped_screen[0][int(f_is_y_dominant)] + fragment_local_idx * f_sign) * f_slope + f_non_dominant_intercept);
		const float interpolation_weight = (fragment_local_idx + 0.5) / float(fragment_range.count);
		#endif

		const vec4 interpolated_ndc = perspective_interpolate_edge(verts_clipped_ndc, interpolation_weight);
		const float godot_depth = interpolated_ndc.z;
		B_contour_fragment_attribs.data[fragment_idx].pixel_coord = pixel_coord;
		B_contour_fragment_attribs.data[fragment_idx].orientation = contour_orientation;
		B_contour_fragment_attribs.data[fragment_idx].normal_depth.xyz = front_face_view_normal;
		B_contour_fragment_attribs.data[fragment_idx].normal_depth.w = godot_depth;
	}
}
