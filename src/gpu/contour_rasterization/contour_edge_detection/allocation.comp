#version 450
#extension GL_ARB_shading_language_include : enable

#include "common/ext/subgroup.glsli"

// NOTE: just one big huge fat workgroup
layout(local_size_x = 1024) in;

#include "common/buffers.glsli"
#include "common/scans.glsli"


shared uint block_offsets[gl_WorkGroupSize.x];
shared uint total_sum;

void main() {
	const BlockPartitionDesc bpd = create_block_partition_desc(gl_NumSubgroups, udiv_ceil(B_mesh_desc.num_edges, gl_SubgroupSize));
	const BlockDesc bd = create_block_desc(bpd, gl_SubgroupID);

	const bool is_participating_stage_0 = bd.block_idx < bpd.num_blocks;
	const bool is_participating_stage_1 = gl_SubgroupID == 0;
	const bool is_participating_stage_2 = bd.block_idx < bpd.num_blocks;

	if (is_participating_stage_0) {
		block_offsets[bd.block_idx] = 0;
		for (uint element_idx = bd.first_element_idx; element_idx <= bd.final_element_idx; ++element_idx) {
			const uint idx = element_idx * gl_SubgroupSize + gl_SubgroupInvocationID;

			uint value = 0;
			if (idx < B_mesh_desc.num_edges) {
				value = uint(B_edge_is_contour.contour[idx]);
			}
			const uint exclusive = subgroupExclusiveAdd(value) + block_offsets[bd.block_idx];
			const uint element_sum = subgroupAdd(value);

			if (subgroupElect()) {
				block_offsets[bd.block_idx] += element_sum;
			}
			if (idx < B_mesh_desc.num_edges) {
				B_edge_to_contour_edge.idx[idx] = int(exclusive);
			}
		}
	}
	barrier();
	if (is_participating_stage_1) {
		total_sum = 0;
		const uint block_idx = gl_SubgroupInvocationID;
		uint value = 0;
		if (block_idx < bpd.num_blocks) {
			value = block_offsets[block_idx];
		}

		const uint exclusive = subgroupExclusiveAdd(value);
		const uint sum = subgroupAdd(value);

		if (subgroupElect()) {
			B_contour_desc.num_contour_edges = int(sum);
		}
		block_offsets[block_idx] = exclusive;
	}
	barrier();
	if (is_participating_stage_2) {
		const int block_offset = int(block_offsets[bd.block_idx]);
		for (uint element_idx = bd.first_element_idx; element_idx <= bd.final_element_idx; ++element_idx) {
			const uint idx = element_idx * gl_SubgroupSize + gl_SubgroupInvocationID;
			if (idx < B_mesh_desc.num_edges) {
				B_edge_to_contour_edge.idx[idx] += block_offset;
			}
		}
	}
	barrier();
}
