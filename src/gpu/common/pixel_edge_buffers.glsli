#ifndef PEL_BUFFERS_GLSLI
#define PEL_BUFFERS_GLSLI

#extension GL_ARB_shading_language_include : enable
#include "common/mem.glsli"

#define MAX_NUM_SPARSE_PIXEL_EDGES (MAX_NUM_CONTOUR_PIXELS * 4)
#define MAX_NUM_FRAGMENTED_PIXEL_EDGES (MAX_NUM_SPARSE_PIXEL_EDGES / 2)
#define MAX_NUM_COMPACTED_PIXEL_EDGES (MAX_NUM_FRAGMENTED_PIXEL_EDGES)
#define MAX_NUM_PIXEL_EDGE_LOOPS (MAX_NUM_COMPACTED_PIXEL_EDGES / 4)
#define MAX_NUM_SEGMENTS_PER_LOOP (1024)
#define MAX_NUM_SEGMENTS (MAX_NUM_COMPACTED_PIXEL_EDGES / 8)
#define MAX_NUM_SEGMENT_EDGES (MAX_NUM_SEGMENTS * 4)


layout(BUFREF_LAYOUT) buffer PixelEdgeDescBuffer {
	int buf_len_sparse_pixel_edge;
	int num_pixel_edges;
	int num_pixel_edge_loops;
	int num_segments;
	int num_segment_edges;
	int num_stroke_vertices;
};


struct PixelEdgeOrientation {
	uint value;
};

#define E_PixelEdgeOrientation_NORTH (0u)
#define E_PixelEdgeOrientation_EAST  (1u)
#define E_PixelEdgeOrientation_SOUTH (2u)
#define E_PixelEdgeOrientation_WEST  (3u)
#define E_PixelEdgeOrientation_MAX   (4u)

#include "common/math.glsli"
#include "common/contour_buffers.glsli"

uint get_sparse_pixel_edge_contour_pixel_idx(in const uint i_sparse_pixel_edge_idx) {
	return i_sparse_pixel_edge_idx / 4u;
}

PixelEdgeOrientation get_sparse_pixel_edge_orientation(in const uint i_sparse_pixel_edge_idx) {
	return PixelEdgeOrientation(i_sparse_pixel_edge_idx % 4u);
}

struct SparsePixelEdgeAttribsData {
	int prev_idx;
	int next_idx;
	bool is_valid;
	int to_fragmented_pixel_edge_idx;
};

layout(BUFREF_LAYOUT) buffer SparsePixelEdgeAttribsBuffer {
	SparsePixelEdgeAttribsData data[MAX_NUM_SPARSE_PIXEL_EDGES];
};


struct FragmentedPixelEdgeAttribsData {
	int to_sparse_pixel_edge_idx;
	int associated_head;
	int loop_local_idx;
	int to_pixel_edge_loop_idx;
};

layout(BUFREF_LAYOUT) buffer FragmentedPixelEdgeAttribsBuffer {
	FragmentedPixelEdgeAttribsData data[MAX_NUM_FRAGMENTED_PIXEL_EDGES];
};

struct FragmentedPixelEdgeWyllieData {
	int next_idx;
	int prev_idx;
	int key;
	uint value;
};

layout(BUFREF_LAYOUT) buffer FragmentedPixelEdgeWyllieBuffer {
	FragmentedPixelEdgeWyllieData data[MAX_NUM_FRAGMENTED_PIXEL_EDGES][2];
};


struct PixelEdgeLoopAttribs {
	int fragmented_head_idx;
	int compacted_head_idx;
	int loop_len;
	int pad;
};

layout(BUFREF_LAYOUT) buffer PixelEdgeLoopAttribsBuffer {
	PixelEdgeLoopAttribs data[MAX_NUM_PIXEL_EDGE_LOOPS];
};


struct CompactedPixelEdgeAttribs {
	int prev_idx;
	int next_idx;
	int to_contour_pixel_idx;
	PixelEdgeOrientation orientation;
	int associated_head;
	int to_pixel_edge_loop_idx;
	vec2 filtered_midpoint;
	vec2 filtered_orientation;
	bool is_inside;
	bool is_discarded;
	int segment_key;
	int to_segment_edge_idx;
};

layout(BUFREF_LAYOUT) buffer CompactedPixelEdgeAttribsBuffer {
	CompactedPixelEdgeAttribs data[MAX_NUM_COMPACTED_PIXEL_EDGES];
};

#define ORIENTATION_FILTERING_MAX_NUM_NEIGHBOURS (8)
#define ORIENTATION_FILTERING_MAX_WINDOW_SIZE (ORIENTATION_FILTERING_MAX_NUM_NEIGHBOURS * 2 + 1)

#define INSIDE_OUTSIDE_TEST_MAX_NUM_NEIGHBOURS (8)
#define INSIDE_OUTSIDE_TEST_MAX_WINDOW_SIZE (INSIDE_OUTSIDE_TEST_MAX_NUM_NEIGHBOURS * 2 + 1)


struct PixelEdgeLoopSegmentationData {
	int num_segments;
	int num_inside_edges;
	int num_segment_edges;
	int loop_segment_key_offset;
	int loop_num_segment_edges_offset;
	int pad;
};

layout(BUFREF_LAYOUT) buffer PixelEdgeLoopSegmentationBuffer {
	PixelEdgeLoopSegmentationData data[MAX_NUM_PIXEL_EDGE_LOOPS];
};


struct CompactedPixelEdgeSegmentationData {
	bool is_inside_initial;
	bool is_segment_head_initial;
	int loop_local_segment_key;
	int segment_head_idx;
	int segment_length;
	int loop_local_allocation_idx;
};

layout(BUFREF_LAYOUT) buffer CompactedPixelEdgeSegmentationBuffer {
	CompactedPixelEdgeSegmentationData data[MAX_NUM_COMPACTED_PIXEL_EDGES];
};

int compacted_pixel_edge_segment_local_idx(in const int i_pixel_edge_idx, in const int i_segment_head_idx, in const int i_loop_len) {
	int local_idx = i_pixel_edge_idx - i_segment_head_idx;
	if (local_idx < 0) {
		local_idx += i_loop_len;
	}
	return local_idx;
}


struct SegmentAttribs {
	Range segment_edges;
	Range stroke_vertices;
	float arc_length;
	int pad;
};

layout(BUFREF_LAYOUT) buffer SegmentAttribsBuffer {
	SegmentAttribs data[MAX_NUM_SEGMENTS];
};


struct SegmentEdgeAttribs {
	int to_compacted_pixel_edge_idx;
	bool is_head;
	float arc_length;
	int pad;
};

layout(BUFREF_LAYOUT) buffer SegmentEdgeAttribsBuffer {
	SegmentEdgeAttribs data[MAX_NUM_SEGMENT_EDGES];
};


#define MAX_NUM_STROKE_VERTICES (MAX_NUM_SEGMENT_EDGES * 4)

#define StrokeVertexKind uint
#define E_StrokeVertexKind_BACK_LEFT   (0u)
#define E_StrokeVertexKind_BACK_RIGHT  (1u)
#define E_StrokeVertexKind_FRONT_LEFT  (2u)
#define E_StrokeVertexKind_FRONT_RIGHT (3u)
#define E_StrokeVertexKind_MAX         (4u)
#define E_StrokeVertexKind_RIGHT_MASK (1u << 0u)
#define E_StrokeVertexKind_FRONT_MASK (1u << 1u)

struct StrokeVertexAttribs {
	int to_segment_edge_idx;
	StrokeVertexKind kind;
};

layout(BUFREF_LAYOUT) buffer StrokeVertexAttribsBuffer {
	StrokeVertexAttribs data[MAX_NUM_SEGMENTS];
};


layout(set = 4, binding = 0, scalar) coherent buffer PixelEdgeBuffers {
	PixelEdgeDescBuffer                         B_pixel_edge_desc;

	SparsePixelEdgeAttribsBuffer                B_sparse_pixel_edge_attribs;
	FragmentedPixelEdgeAttribsBuffer            B_fragmented_pixel_edge_attribs;
	FragmentedPixelEdgeWyllieBuffer             B_fragmented_pixel_edge_wyllie;

	PixelEdgeLoopAttribsBuffer                  B_pixel_edge_loop_attribs;
	CompactedPixelEdgeAttribsBuffer             B_compacted_pixel_edge_attribs;

	CompactedPixelEdgeSegmentationBuffer        B_compacted_pixel_edge_segmentation;
	PixelEdgeLoopSegmentationBuffer             B_pixel_edge_loop_segmentation;

	SegmentAttribsBuffer                        B_segment_attribs;
	SegmentEdgeAttribsBuffer                    B_segment_edge_attribs;
	StrokeVertexAttribsBuffer                   B_stroke_vertex_attribs;
};


bool is_sparse_pixel_edge_idx_valid(in const int i_idx) {
	return (
		i_idx >= 0 &&
		i_idx < B_pixel_edge_desc.buf_len_sparse_pixel_edge &&
		B_sparse_pixel_edge_attribs.data[i_idx].is_valid
	);
}

bool is_fragmented_pixel_edge_idx_valid(in const int i_idx) {
	return (
		i_idx >= 0 &&
		i_idx < B_pixel_edge_desc.num_pixel_edges
	);
}

bool is_compacted_pixel_edge_idx_valid(in const int i_idx) {
	return (
		i_idx >= 0 &&
		i_idx < B_pixel_edge_desc.num_pixel_edges
	);
}

#endif // !PEL_BUFFERS_GLSLI
