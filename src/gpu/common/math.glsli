#include "common/contour_buffers.glsli"

 int idiv_floor( int n,  int d) { return n / d -  int((n % d) != 0 && (n^d) < 0); }
 int idiv_ceil ( int n,  int d) { return n / d +  int((n % d) != 0 && (n^d) > 0); }
uint udiv_floor(uint n, uint d) { return n / d; } // just for the sake of consistency
uint udiv_ceil (uint n, uint d) { return n / d + uint((n % d) != 0); }

float sqr(in const float i_a) { return i_a * i_a; }
uint  sqr(in const uint  i_a) { return i_a * i_a; }

// upper limit is exclusive
bool is_within_aabb(in ivec2 i_point, in ivec2 i_aabb_min, in uvec2 i_aabb_size) {
	bool passed = (
		i_point == max(i_point, i_aabb_min) &&
		i_point == min(i_point, i_aabb_min + i_aabb_size - 1)
	);
	return passed;
}

// upper limit is exclusive
bool is_within_screen(in ivec2 i_point, in uvec2 i_screen_size) {
	return is_within_aabb(i_point, ivec2(0, 0), i_screen_size);
}

PixelEdgeOrientation orientation_op_add(in const PixelEdgeOrientation i_a, in const int i_b) {
	return PixelEdgeOrientation((int(i_a.value + E_PixelEdgeOrientation_MAX) + i_b) % E_PixelEdgeOrientation_MAX);
}

PixelEdgeOrientation get_prev_orientation(in const PixelEdgeOrientation i_orientation) {
	return orientation_op_add(i_orientation, -1);
}

PixelEdgeOrientation get_next_orientation(in const PixelEdgeOrientation i_orientation) {
	return orientation_op_add(i_orientation, 1);
}

ivec4 get_orientation_local_axes(in const PixelEdgeOrientation i_orientation) {
	switch (i_orientation.value) {
		case E_PixelEdgeOrientation_NORTH:
			return ivec4( 1, 0, 0,-1);
		case E_PixelEdgeOrientation_EAST:
			return ivec4( 0, 1, 1, 0);
		case E_PixelEdgeOrientation_SOUTH:
			return ivec4(-1, 0, 0, 1);
		case E_PixelEdgeOrientation_WEST:
			return ivec4( 0,-1,-1, 0);
	}
	return ivec4(0);
}

ivec2 mult_axes(in const ivec4 i_axes, in const ivec2 i_vec) {
	return i_axes.xy * i_vec.x + i_axes.zw * i_vec.y;
}

uint calc_sparse_pixel_edge_morton_code(in const PixelEdgeOrientation i_orientation, in const ivec2 i_contour_pixel_pixel_coord) {
	return (
		((E_PixelEdgeOrientation_MAX - 1u - i_orientation.value)  << 30u) +
		((uint(i_contour_pixel_pixel_coord.x) & (1u << 15u) - 1u) << 15u) +
		((uint(i_contour_pixel_pixel_coord.y) & (1u << 15u) - 1u) <<  0u)
	);
}

uint get_invalid_morton_code() {
	return 0u - 1u;
}

