#ifndef MATH_GLSLI
#define MATH_GLSLI

struct Range {
	int first;
	int count;
};
#define _SIZEOF_Range() ((_M_SIZEOF(int)()) * 2ul)

//  int idiv_floor( int n,  int d) { return n / d -  int((n % d) != 0 && (n^d) < 0); }
//  int idiv_ceil ( int n,  int d) { return n / d +  int((n % d) != 0 && (n^d) > 0); }
uint udiv_floor(uint n, uint d) { return n / d; } // just for the sake of consistency
uint udiv_ceil (uint n, uint d) { return n / d + uint((n % d) != 0); }

float sqr(in const float i_a) { return i_a * i_a; }
uint  sqr(in const uint  i_a) { return i_a * i_a; }

float laplacian(in const float i_a, in const float i_b, in const float i_c) {
	return i_a + i_c - 2 * i_b;
}

vec2  laplacian(in const vec2  i_a, in const vec2  i_b, in const vec2  i_c) {
	return vec2(laplacian(i_a[0], i_b[0], i_c[0]), laplacian(i_a[1], i_b[1], i_c[1]));
}

float laplacian_filtering(in const float i_factor, in const float i_a, in const float i_b, in const float i_c) {
	return i_b + i_factor * laplacian(i_a, i_b, i_c);
}

vec2  laplacian_filtering(in const float i_factor, in const vec2  i_a, in const vec2  i_b, in const vec2  i_c) {
	return i_b + i_factor * laplacian(i_a, i_b, i_c);
}

// upper limit is exclusive
bool is_within_aabb(in ivec2 i_point, in ivec2 i_aabb_min, in uvec2 i_aabb_size) {
	bool passed = (
		i_point == max(i_point, i_aabb_min) &&
		i_point == min(i_point, i_aabb_min + i_aabb_size - 1)
	);
	return passed;
}

// upper limit is exclusive
bool is_within_screen(in ivec2 i_point, in uvec2 i_screen_size) {
	return is_within_aabb(i_point, ivec2(0, 0), i_screen_size);
}

#extension GL_ARB_shading_language_include : require
#include "common/common_buffers.glsli"

PixelEdgeOrientation orientation_op_add(in const PixelEdgeOrientation i_a, in const int i_b) {
	return PixelEdgeOrientation((int(i_a.value + E_PixelEdgeOrientation_MAX) + i_b) % E_PixelEdgeOrientation_MAX);
}

PixelEdgeOrientation get_prev_orientation(in const PixelEdgeOrientation i_orientation) {
	return orientation_op_add(i_orientation, -1);
}

PixelEdgeOrientation get_next_orientation(in const PixelEdgeOrientation i_orientation) {
	return orientation_op_add(i_orientation, 1);
}

ivec4 get_orientation_local_axes(in const PixelEdgeOrientation i_orientation) {
	switch (i_orientation.value) {
		case E_PixelEdgeOrientation_NORTH:
			return ivec4( 1, 0, 0,-1);
		case E_PixelEdgeOrientation_EAST:
			return ivec4( 0, 1, 1, 0);
		case E_PixelEdgeOrientation_SOUTH:
			return ivec4(-1, 0, 0, 1);
		case E_PixelEdgeOrientation_WEST:
			return ivec4( 0,-1,-1, 0);
	}
	return ivec4(0);
}

ivec2 mult_axes(in const ivec4 i_axes, in const ivec2 i_vec) {
	return i_axes.xy * i_vec.x + i_axes.zw * i_vec.y;
}

uint calc_sparse_pixel_edge_morton_code(in const PixelEdgeOrientation i_orientation, in const ivec2 i_contour_pixel_pixel_coord) {
	return (
		((E_PixelEdgeOrientation_MAX - 1u - i_orientation.value)  << 30u) +
		((uint(i_contour_pixel_pixel_coord.x) & (1u << 15u) - 1u) << 15u) +
		((uint(i_contour_pixel_pixel_coord.y) & (1u << 15u) - 1u) <<  0u)
	);
}

uint get_invalid_morton_code() {
	return 0u - 1u;
}

#endif // !MATH_GLSLI
