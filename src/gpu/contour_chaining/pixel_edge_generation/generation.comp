#version 460
#extension GL_ARB_shading_language_include : require

layout(local_size_x = 64) in;

#include "common/buffers.glsli"
#include "common/math.glsli"


void main() {
	const uint pixel_edge_idx = gl_GlobalInvocationID.x;
	const uint contour_pixel_idx = get_sparse_pixel_edge_contour_pixel_idx(pixel_edge_idx);
	const PixelEdgeOrientation orientation = get_sparse_pixel_edge_orientation(pixel_edge_idx);

	if (pixel_edge_idx < B_common_desc.buf_len_sparse_pixel_edge) {
		// initialize buffer
		B_sparse_pixel_edge_attribs.data[pixel_edge_idx].prev_idx = -1;
		B_sparse_pixel_edge_attribs.data[pixel_edge_idx].next_idx = -1;
		B_sparse_pixel_edge_attribs.data[pixel_edge_idx].is_valid = store_bool(false);

		const ivec4 local_axes = get_orientation_local_axes(orientation);
		const ivec2 pixel_coord = B_contour_pixel_attribs.data[contour_pixel_idx].pixel_coord;
		const int left_contour_fragment_idx = int(imageLoad(U_foremost_fragment_bitmap, pixel_coord + mult_axes(local_axes, ivec2(-1, 0))).x) - 1;
		if (left_contour_fragment_idx == -1) {
			const int  ahead_left_contour_fragment_idx  = int(imageLoad(U_foremost_fragment_bitmap, pixel_coord + mult_axes(local_axes, ivec2(-1, 1))).x) - 1;
			const int  ahead_right_contour_fragment_idx = int(imageLoad(U_foremost_fragment_bitmap, pixel_coord + mult_axes(local_axes, ivec2( 0, 1))).x) - 1;
			const int behind_left_contour_fragment_idx  = int(imageLoad(U_foremost_fragment_bitmap, pixel_coord + mult_axes(local_axes, ivec2(-1,-1))).x) - 1;
			const int behind_right_contour_fragment_idx = int(imageLoad(U_foremost_fragment_bitmap, pixel_coord + mult_axes(local_axes, ivec2( 0,-1))).x) - 1;

			uint next_contour_pixel_idx;
			PixelEdgeOrientation next_orientation;

			if (ahead_left_contour_fragment_idx != -1) {
				next_contour_pixel_idx = B_contour_fragment_attribs.data[ahead_left_contour_fragment_idx].to_contour_pixel_idx;
				next_orientation = get_prev_orientation(orientation);
			}
			else if (ahead_right_contour_fragment_idx != -1) {
				next_contour_pixel_idx = B_contour_fragment_attribs.data[ahead_right_contour_fragment_idx].to_contour_pixel_idx;
				next_orientation = orientation;
			}
			else {
				next_contour_pixel_idx = contour_pixel_idx;
				next_orientation = get_next_orientation(orientation);
			}

			uint prev_contour_pixel_idx;
			PixelEdgeOrientation prev_orientation;

			if (behind_left_contour_fragment_idx != -1) {
				prev_contour_pixel_idx = B_contour_fragment_attribs.data[behind_left_contour_fragment_idx].to_contour_pixel_idx;
				prev_orientation = get_next_orientation(orientation);
			}
			else if (behind_right_contour_fragment_idx != -1) {
				prev_contour_pixel_idx = B_contour_fragment_attribs.data[behind_right_contour_fragment_idx].to_contour_pixel_idx;
				prev_orientation = orientation;
			}
			else {
				prev_contour_pixel_idx = contour_pixel_idx;
				prev_orientation = get_prev_orientation(orientation);
			}

			B_sparse_pixel_edge_attribs.data[pixel_edge_idx].prev_idx = int(prev_contour_pixel_idx * 4 + prev_orientation.value);
			B_sparse_pixel_edge_attribs.data[pixel_edge_idx].next_idx = int(next_contour_pixel_idx * 4 + next_orientation.value);
			B_sparse_pixel_edge_attribs.data[pixel_edge_idx].is_valid = store_bool(true);
		}
		const int here_contour_fragment_idx = int(imageLoad(U_foremost_fragment_bitmap, pixel_coord).x) - 1;
		if (here_contour_fragment_idx == -1 || contour_pixel_idx != B_contour_fragment_attribs.data[here_contour_fragment_idx].to_contour_pixel_idx) {
			B_sparse_pixel_edge_attribs.data[pixel_edge_idx].prev_idx = -1;
			B_sparse_pixel_edge_attribs.data[pixel_edge_idx].next_idx = -1;
			B_sparse_pixel_edge_attribs.data[pixel_edge_idx].is_valid = store_bool(false);
		}
	}
}
