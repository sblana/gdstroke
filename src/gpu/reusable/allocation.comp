#version 450
#extension GL_ARB_shading_language_include : enable

#define L0_WORKGROUP_SIZE 1024

#ifdef COMMANDER
	#define WORKGROUP_SIZE 1
	#include  "common/command_buffers.glsli"
#else
	#define WORKGROUP_SIZE L0_WORKGROUP_SIZE
#endif

layout(local_size_x = WORKGROUP_SIZE) in;

#include "common/buffers.glsli"
#include "common/scans.glsli"


layout(push_constant) RESTRICT uniform PushConstants {
	AllocationPushData U_push;
};


shared int block_offsets[gl_WorkGroupSize.x];

#define fn_get_src_array(MP_idx_)                     (i32ref_index_into_buffer(src_buffer_ptr, U_push.src_offset, U_push.src_stride, (MP_idx_)).value)
#define fn_set_src_to_dst_map(MP_idx_, MP_value_)     (i32ref_index_into_buffer(src_to_dst_map_buffer_ptr, U_push.src_to_dst_map_offset, U_push.src_to_dst_map_stride, (MP_idx_)).value  = MP_value_)
#define fn_add_set_src_to_dst_map(MP_idx_, MP_value_) (i32ref_index_into_buffer(src_to_dst_map_buffer_ptr, U_push.src_to_dst_map_offset, U_push.src_to_dst_map_stride, (MP_idx_)).value += MP_value_)

#define fn_get_intermediate_sums(MP_idx_)            int(B_allocation_column_edge.column_sum[MP_idx_])
#define fn_set_intermediate_sums(MP_idx_, MP_value_) B_allocation_column_edge.column_sum[MP_idx_] = MP_value_

#define fn_get_intermediate_offsets(MP_idx_)                int(B_allocation_column_edge.column_offset[MP_idx_])
#define fn_set_intermediate_offsets(MP_idx_, MP_value_)     B_allocation_column_edge.column_offset[MP_idx_]  = MP_value_
#define fn_add_set_intermediate_offsets(MP_idx_, MP_value_) B_allocation_column_edge.column_offset[MP_idx_] += MP_value_

void main() {
	UInt64 src_buffer_ptr            = UInt64Reference(U_push.src_buffer_indirect_ptr).value;
	UInt64 src_to_dst_map_buffer_ptr = UInt64Reference(U_push.src_to_dst_map_buffer_indirect_ptr).value;
	UInt64 src_num_elements_ptr      = UInt64Reference(U_push.src_num_elements_indirect_ptr).value;
	UInt64 dst_num_elements_ptr      = UInt64Reference(U_push.dst_num_elements_indirect_ptr).value;
	readonly  Int32Reference src_num_elements = Int32Reference(src_num_elements_ptr + U_push.src_num_elements_offset);
	writeonly Int32Reference dst_num_elements = Int32Reference(dst_num_elements_ptr + U_push.dst_num_elements_offset);

	const uint level_0_num_workgroups = udiv_ceil(src_num_elements.value, L0_WORKGROUP_SIZE);

	#ifdef COMMANDER

		if (gl_GlobalInvocationID.x == 0) {
			DispatchIndirectCommand command;
			command.workgroups_x = level_0_num_workgroups;
			command.workgroups_y = 1;
			command.workgroups_z = 1;
			B_dispatch_indirect_commands.cmds[E_DispatchIndirectCommand_REUSABLE_ALLOCATION_L0] = command;
		}

	#else

		#ifdef UP_SWEEP
		#define is_upsweep 1
		#else
		#define is_upsweep 0
		#endif

		#ifdef LEVEL_0
		#define is_level_0 1
		#else
		#define is_level_0 0
		#endif

		M_GLOBAL_ALLOCATION(
			int,
			block_offsets,
			src_num_elements.value,
			fn_get_src_array,
			dst_num_elements.value,
			fn_get_intermediate_sums,
			fn_set_intermediate_sums,
			fn_get_intermediate_offsets,
			fn_set_intermediate_offsets,
			fn_add_set_intermediate_offsets,
			fn_set_src_to_dst_map,
			fn_add_set_src_to_dst_map,
			level_0_num_workgroups,
			is_level_0,
			is_upsweep
		)

	#endif // COMMANDER
}
