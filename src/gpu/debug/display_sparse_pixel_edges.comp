#version 450
#extension GL_ARB_shading_language_include : enable

layout(local_size_x = 64) in;

#include "common/buffers.glsli"
#include "common/debug_buffers.glsli"
#include "common/math.glsli"


void main() {
	const uint pixel_edge_idx = gl_GlobalInvocationID.x;
	const uint contour_pixel_idx = get_sparse_pixel_edge_contour_pixel_idx(pixel_edge_idx);
	const PixelEdgeOrientation orientation = get_sparse_pixel_edge_orientation(pixel_edge_idx);
	const SparsePixelEdgeNeighboursData neighbours = B_sparse_pixel_edge_neighbours.data[pixel_edge_idx];

	if (is_sparse_pixel_edge_idx_valid(int(pixel_edge_idx))) {
		const ivec4 local_axes = get_orientation_local_axes(orientation);
		const ivec2 contour_pixel_coord = B_contour_pixel_pixel_coord.pixel_coord[contour_pixel_idx];
		const ivec2 left_pixel_coord = contour_pixel_coord + mult_axes(local_axes, ivec2(-1, 0));

		const uint associated_head_idx = B_sparse_pixel_edge_associated_head.associated_head[pixel_edge_idx];
		const uint loop_len = B_sparse_pixel_edge_local_idx.local_idx[B_sparse_pixel_edge_neighbours.data[associated_head_idx].prev_idx] + 1u;

		const bool prev_neighbour_valid = is_sparse_pixel_edge_idx_valid(neighbours.prev_idx);
		const bool next_neighbour_valid = is_sparse_pixel_edge_idx_valid(neighbours.next_idx);

		if (is_within_screen(left_pixel_coord, imageSize(U_screen_color_image))) {
			const vec4 output_data = vec4(
				// float(pixel_edge_idx) / B_pixel_edge_desc.buf_len_sparse_pixel_edge,
				// 0.0,

				// 0.5 + 0.5 * local_axes.z,
				// 0.5 + 0.5 * local_axes.w,

				sqr(float(B_sparse_pixel_edge_local_idx.local_idx[pixel_edge_idx]) / (loop_len - 1u)),
				sqr(float(B_sparse_pixel_edge_local_idx.local_idx[pixel_edge_idx]) / (loop_len - 1u)),

				(prev_neighbour_valid && next_neighbour_valid) ? 0.0 : 1.0,

				1.0
			);
			imageStore(U_screen_color_image, left_pixel_coord, output_data);
		}
	}
}
